#!/usr/bin/env python3
"""Send (or preview) review reminder notifications when files are missing.

This helper inspects the reviewer assignment CSV generated by
`proposal_to_review_template.py`, cross-checks the renamed review files in the
specified directory, retrieves reviewer email addresses from `EVN_pc_members.txt`,
and—after a given deadline—reports or emails reminders for any reviewers who have
not yet submitted their files.
"""

from __future__ import annotations

import argparse
import csv
import re
import smtplib
import sys
from dataclasses import dataclass
from datetime import datetime
from email.message import EmailMessage
from pathlib import Path
from typing import Dict, Iterable, List, Mapping, Optional, Sequence, Tuple

from proposal_to_review_template import load_pc_members

NAME_TOKEN_RE = re.compile(r"[a-z0-9]+", re.IGNORECASE)
PROPOSAL_RE = re.compile(r"[A-Z]\d{2}[A-Z]\d{3}", re.IGNORECASE)


@dataclass
class Assignment:
    proposal: str
    reviewer: str
    role: str


@dataclass
class Reminder:
    reviewer: str
    email: Optional[str]
    proposals: List[Tuple[str, str]]


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Send reminders for missing EVN PC reviews once the deadline has passed.",
    )
    parser.add_argument(
        "--assignments",
        type=Path,
        default=Path("reviewer_assignments.txt"),
        help="CSV file produced by proposal_to_review_template.py (default: reviewer_assignments.txt).",
    )
    parser.add_argument(
        "--reviews-dir",
        type=Path,
        default=Path("reviews"),
        help="Directory containing collected review files (default: ./reviews).",
    )
    parser.add_argument(
        "--pc-members",
        type=Path,
        default=Path("EVN_pc_members.txt"),
        help="PC member roster (default: ./EVN_pc_members.txt) used to look up reviewer email addresses.",
    )
    parser.add_argument(
        "--due-date",
        required=True,
        help="Deadline in ISO format (YYYY-MM-DD or YYYY-MM-DDTHH:MM).",
    )
    parser.add_argument(
        "--current-date",
        help="Override the current timestamp (ISO format) for testing or backfilling.",
    )
    parser.add_argument(
        "--from-address",
        help="Email address used in the From header when sending reminders.",
    )
    parser.add_argument(
        "--reply-to",
        help="Optional Reply-To address for outgoing reminder emails.",
    )
    parser.add_argument(
        "--cc",
        action="append",
        default=[],
        help="Additional recipients to CC on reminder emails (can be supplied multiple times).",
    )
    parser.add_argument(
        "--smtp-server",
        help="SMTP server hostname. When omitted, reminders are only printed.",
    )
    parser.add_argument(
        "--smtp-port",
        type=int,
        default=587,
        help="SMTP server port (default: 587).",
    )
    parser.add_argument(
        "--smtp-username",
        help="SMTP username (if authentication is required).",
    )
    parser.add_argument(
        "--smtp-password",
        help="SMTP password (if authentication is required).",
    )
    parser.add_argument(
        "--smtp-use-ssl",
        action="store_true",
        help="Use SMTP over SSL instead of STARTTLS.",
    )
    parser.add_argument(
        "--subject-template",
        default="Reminder: pending EVN review(s) for {proposal_list}",
        help="Email subject template. Available tokens: {proposal}, {proposal_list}, {reviewer}, {count}, {today}.",
    )
    parser.add_argument(
        "--message-template",
        default=(
            "Dear {reviewer},\n\n"
            "This is a reminder that the following review(s) are still outstanding as of {today}:\n"
            "{details}\n\n"
            "Please upload your review to the shared folder as soon as possible.\n\n"
            "Kind regards,\n"
            "EVN Programme Committee Chair"
        ),
        help=(
            "Plain-text email body template. Available tokens: {reviewer}, {proposal}, {role}, "
            "{proposal_list}, {details}, {count}, {today}."
        ),
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Do not send emails; print the reminders to stdout instead.",
    )
    parser.add_argument(
        "--summary-only",
        action="store_true",
        help="Only print a summary report (no per-reviewer reminder content).",
    )
    return parser.parse_args(argv)


def parse_iso_datetime(value: str, label: str) -> datetime:
    try:
        parsed = datetime.fromisoformat(value)
    except ValueError as exc:
        raise ValueError(f"Invalid {label} '{value}'; expected ISO format YYYY-MM-DD or YYYY-MM-DDTHH:MM") from exc
    return parsed


def tokenise(text: str) -> List[str]:
    return NAME_TOKEN_RE.findall(text.lower())


def canonical_name(value: str) -> str:
    tokens = tokenise(value)
    return " ".join(tokens)


def load_assignments(path: Path) -> List[Assignment]:
    if not path.is_file():
        raise FileNotFoundError(f"Assignments file not found: {path}")

    with path.open(newline="", encoding="utf-8") as handle:
        reader = csv.reader(handle)
        try:
            header = next(reader)
        except StopIteration:
            return []

        header_tokens = [column.strip() for column in header]
        if not header_tokens or not header_tokens[0].lower().startswith("proposal"):
            raise ValueError(f"Unexpected assignments header in {path}; first column must be 'Proposal'.")
        roles = header_tokens[1:]

        assignments: List[Assignment] = []
        for row in reader:
            if not row:
                continue
            proposal = row[0].strip()
            if not proposal:
                continue
            for idx, role in enumerate(roles, start=1):
                if idx >= len(row):
                    break
                reviewer = row[idx].strip()
                if reviewer:
                    assignments.append(Assignment(proposal=proposal, reviewer=reviewer, role=role))
    return assignments


def collect_review_file_signatures(reviews_dir: Path) -> List[Tuple[Path, List[str]]]:
    if not reviews_dir.exists():
        return []
    signatures: List[Tuple[Path, List[str]]] = []
    for path in sorted(reviews_dir.rglob("*")):
        if not path.is_file():
            continue
        tokens = tokenise(path.stem.replace("-", " "))
        if not tokens:
            continue
        signatures.append((path, tokens))
    return signatures


def find_review(
    proposal: str,
    reviewer: str,
    files: Iterable[Tuple[Path, List[str]]],
) -> Optional[Path]:
    proposal_token = canonical_name(proposal)
    reviewer_tokens = tokenise(reviewer)
    if not proposal_token or not reviewer_tokens:
        return None

    proposal_tokens = set(tokenise(proposal_token))
    reviewer_token_set = set(reviewer_tokens)

    for path, tokens in files:
        token_set = set(tokens)
        if proposal_tokens - token_set:
            continue
        if reviewer_token_set.issubset(token_set):
            return path

        # Fallback: attempt to extract reviewer name from remainder of filename.
        stem = path.stem
        match = PROPOSAL_RE.search(stem)
        if match:
            remainder = (stem[: match.start()] + " " + stem[match.end() :]).strip()
            remainder_tokens = set(tokenise(remainder))
            if reviewer_token_set.issubset(remainder_tokens):
                return path
    return None


def build_reminders(
    assignments: Sequence[Assignment],
    files: Iterable[Tuple[Path, List[str]]],
    contacts: Mapping[str, str],
) -> Dict[str, Reminder]:
    reminders: Dict[str, Reminder] = {}
    file_cache = list(files)
    for assignment in assignments:
        found = find_review(assignment.proposal, assignment.reviewer, file_cache)
        if found:
            continue

        reviewer_key = canonical_name(assignment.reviewer)
        entry = reminders.get(reviewer_key)
        if entry is None:
            email = contacts.get(reviewer_key)
            entry = Reminder(reviewer=assignment.reviewer, email=email, proposals=[])
            reminders[reviewer_key] = entry
        entry.proposals.append((assignment.proposal, assignment.role))
    return reminders


def send_reminder_email(
    reminder: Reminder,
    today: datetime,
    subject_template: str,
    body_template: str,
    args: argparse.Namespace,
) -> None:
    if not reminder.proposals:
        return

    today_str = today.strftime("%Y-%m-%d")
    first_proposal, first_role = reminder.proposals[0]
    proposal_list = ", ".join(proposal for proposal, _ in reminder.proposals)
    details = "\n".join(f"- {proposal} ({role})" for proposal, role in reminder.proposals)
    context = {
        "reviewer": reminder.reviewer,
        "proposal": first_proposal,
        "role": first_role,
        "proposal_list": proposal_list,
        "details": details,
        "count": len(reminder.proposals),
        "today": today_str,
    }
    subject = subject_template.format(**context)
    body = body_template.format(**context)

    if not args.smtp_server:
        print(format_reminder_text(reminder, today), flush=True)
        return

    if not reminder.email:
        print(format_reminder_text(reminder, today), flush=True)
        print("  (No email address available; reminder not sent.)")
        return

    if args.dry_run:
        print(f"[DRY-RUN] Would send to {reminder.email} :: {subject}\n{body}\n", flush=True)
        return

    sender = args.from_address or args.smtp_username
    if not sender:
        raise ValueError("A --from-address (or SMTP username) is required to send emails.")

    message = EmailMessage()
    message["Subject"] = subject
    message["From"] = sender
    message["To"] = reminder.email
    if args.reply_to:
        message["Reply-To"] = args.reply_to
    if args.cc:
        message["Cc"] = ", ".join(args.cc)
    message.set_content(body)

    deliver_email(args, message)


def deliver_email(args: argparse.Namespace, message: EmailMessage) -> None:
    if args.smtp_use_ssl:
        server: smtplib.SMTP = smtplib.SMTP_SSL(args.smtp_server, args.smtp_port)
    else:
        server = smtplib.SMTP(args.smtp_server, args.smtp_port)
        server.ehlo()
        if not args.smtp_use_ssl:
            try:
                server.starttls()
                server.ehlo()
            except smtplib.SMTPException:
                pass
    try:
        if args.smtp_username and args.smtp_password:
            server.login(args.smtp_username, args.smtp_password)
        server.send_message(message)
    finally:
        server.quit()


def format_reminder_text(reminder: Reminder, today: datetime) -> str:
    lines = [
        f"Reminder for {reminder.reviewer} ({reminder.email or 'no email available'})",
        f"  Outstanding as of {today.strftime('%Y-%m-%d')}:",
    ]
    for proposal, role in reminder.proposals:
        lines.append(f"    - {proposal} ({role})")
    return "\n".join(lines)


def print_summary(reminders: Dict[str, Reminder], today: datetime) -> None:
    if not reminders:
        print(f"All reviews submitted as of {today.strftime('%Y-%m-%d')}.")
        return
    total = sum(len(item.proposals) for item in reminders.values())
    reviewers = ", ".join(sorted(item.reviewer for item in reminders.values()))
    print(f"{total} outstanding review(s) across {len(reminders)} reviewer(s): {reviewers}")


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)

    try:
        due_date = parse_iso_datetime(args.due_date, "due date")
        current_date = parse_iso_datetime(args.current_date, "current date") if args.current_date else datetime.now()
    except ValueError as exc:
        print(exc, file=sys.stderr)
        return 2

    if current_date < due_date:
        print(
            f"Current date {current_date.strftime('%Y-%m-%d %H:%M')} is before the deadline "
            f"{due_date.strftime('%Y-%m-%d %H:%M')}; no reminders sent.",
        )
        return 0

    try:
        assignments = load_assignments(args.assignments)
    except (FileNotFoundError, ValueError) as exc:
        print(exc, file=sys.stderr)
        return 1

    try:
        _member_names, _fixed, member_emails = load_pc_members(args.pc_members)
    except (FileNotFoundError, ValueError) as exc:
        print(exc, file=sys.stderr)
        return 1
    contacts: Dict[str, str] = {canonical_name(name): email for name, email in member_emails.items()}

    file_signatures = collect_review_file_signatures(args.reviews_dir)
    reminders = build_reminders(assignments, file_signatures, contacts)

    print_summary(reminders, current_date)

    if args.summary_only or not reminders:
        return 0

    try:
        for reminder in reminders.values():
            send_reminder_email(reminder, current_date, args.subject_template, args.message_template, args)
    except ValueError as exc:
        print(exc, file=sys.stderr)
        return 1
    except smtplib.SMTPException as exc:
        print(f"SMTP error: {exc}", file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
