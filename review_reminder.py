#!/usr/bin/env python3
"""Send (or preview) review reminder notifications when files are missing.

This helper inspects the reviewer assignment CSV generated by
`proposal_to_review_template.py`, cross-checks the renamed review files in the
specified directory, retrieves reviewer email addresses from `EVN_pc_members.txt`,
and—after the applicable per-role deadline—reports or emails reminders for any
reviewers who have not yet submitted their files.
"""

from __future__ import annotations

import argparse
import csv
import re
import smtplib
import sys
from dataclasses import dataclass
from datetime import datetime
from email.message import EmailMessage
from pathlib import Path
from typing import Dict, Iterable, List, Mapping, Optional, Sequence, Tuple

from proposal_to_review_template import load_pc_members

NAME_TOKEN_RE = re.compile(r"[a-z0-9]+", re.IGNORECASE)
PROPOSAL_RE = re.compile(r"[A-Z]\d{2}[A-Z]\d{3}", re.IGNORECASE)
PROPOSAL_HEADER_RE = re.compile(
    r"^(?P<code>[A-Z]\d{2}[A-Z]\d{3})(?:\s{2,}|\s*$)",
    re.IGNORECASE,
)
SECTION_LABELS = ("Grade:", "Referee comments:", "Technical review:", "Time recommended:")


@dataclass
class Assignment:
    proposal: str
    reviewer: str
    role: str


@dataclass
class Reminder:
    reviewer: str
    email: Optional[str]
    proposals: List[Tuple[str, str]]


@dataclass
class ReviewFile:
    path: Path
    tokens: List[str]
    proposals: Dict[str, bool]


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Send reminders for missing EVN PC reviews once the deadline has passed.",
    )
    parser.add_argument(
        "--assignments",
        type=Path,
        default=Path("reviewer_assignments.txt"),
        help="CSV file produced by proposal_to_review_template.py (default: reviewer_assignments.txt).",
    )
    parser.add_argument(
        "--reviews-dir",
        type=Path,
        default=Path("reviews"),
        help="Directory containing collected review files (default: ./reviews).",
    )
    parser.add_argument(
        "--pc-members",
        type=Path,
        default=Path("EVN_pc_members.txt"),
        help="PC member roster (default: ./EVN_pc_members.txt) used to look up reviewer email addresses.",
    )
    parser.add_argument(
        "--due-dates",
        type=Path,
        required=True,
        help=(
            "Text file containing per-role review deadlines, formatted like "
            "'First review: YYYY-MM-DD' on separate lines."
        ),
    )
    parser.add_argument(
        "--current-date",
        help="Override the current timestamp (ISO format) for testing or backfilling.",
    )
    parser.add_argument(
        "--from-address",
        help="Email address used in the From header when sending reminders.",
    )
    parser.add_argument(
        "--reply-to",
        help="Optional Reply-To address for outgoing reminder emails.",
    )
    parser.add_argument(
        "--cc",
        action="append",
        default=[],
        help="Additional recipients to CC on reminder emails (can be supplied multiple times).",
    )
    parser.add_argument(
        "--smtp-server",
        default="smtp.gmail.com",
        help="SMTP server hostname (default: smtp.gmail.com).",
    )
    parser.add_argument(
        "--smtp-port",
        type=int,
        default=587,
        help="SMTP server port (default: 587).",
    )
    parser.add_argument(
        "--smtp-username",
        help="SMTP username (if authentication is required).",
    )
    parser.add_argument(
        "--smtp-password",
        help="SMTP password (if authentication is required).",
    )
    parser.add_argument(
        "--smtp-use-ssl",
        action="store_true",
        help="Use SMTP over SSL instead of STARTTLS.",
    )
    parser.add_argument(
        "--subject-template",
        default="Reminder: pending EVN review(s) for {proposal_list}",
        help="Email subject template. Available tokens: {proposal}, {proposal_list}, {reviewer}, {count}, {today}.",
    )
    parser.add_argument(
        "--message-template",
        default=(
            "Dear {reviewer},\n\n"
            "This is a reminder that the following review(s) are still outstanding as of {today}:\n"
            "{details}\n\n"
            "Please upload your review to the shared folder as soon as possible.\n\n"
            "Kind regards,\n"
            "EVN Programme Committee Chair"
        ),
        help=(
            "Plain-text email body template. Available tokens: {reviewer}, {proposal}, {role}, "
            "{proposal_list}, {details}, {count}, {today}."
        ),
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Do not send emails; print the reminders to stdout instead.",
    )
    parser.add_argument(
        "--summary-only",
        action="store_true",
        help="Only print a summary report (no per-reviewer reminder content).",
    )
    parser.add_argument(
        "--export-emails",
        type=Path,
        help="Directory to save reminder emails as text files for manual sending or archiving.",
    )
    return parser.parse_args(argv)


def parse_iso_datetime(value: str, label: str) -> datetime:
    try:
        parsed = datetime.fromisoformat(value)
    except ValueError as exc:
        raise ValueError(f"Invalid {label} '{value}'; expected ISO format YYYY-MM-DD or YYYY-MM-DDTHH:MM") from exc
    return parsed


def normalise_due_date_label(label: str) -> str:
    lowered = label.strip().lower()
    if lowered.startswith("first"):
        return "first"
    if lowered.startswith("second"):
        return "second"
    if lowered.startswith("additional"):
        return "additional"
    raise ValueError(f"Unrecognised due date label '{label}'. Expected First, Second, or Additional.")


def load_due_dates(path: Path) -> Dict[str, datetime]:
    if not path.is_file():
        raise FileNotFoundError(f"Due date file not found: {path}")

    due_dates: Dict[str, datetime] = {}
    with path.open(encoding="utf-8") as handle:
        for raw_line in handle:
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue
            if ":" not in line:
                raise ValueError(f"Invalid due date line '{line}'; expected 'Label: YYYY-MM-DD'.")
            label, value = line.split(":", 1)
            key = normalise_due_date_label(label)
            due_dates[key] = parse_iso_datetime(value.strip(), f"{label.strip()} due date")

    missing = [label for label in ("first", "second", "additional") if label not in due_dates]
    if missing:
        raise ValueError(f"Missing due date(s) for: {', '.join(missing)}.")
    return due_dates


DUE_DATE_DISPLAY_NAMES = {
    "first": "First review",
    "second": "Second review",
    "additional": "Additional reviews",
}


def due_date_for_role(role: str, due_dates: Mapping[str, datetime]) -> datetime:
    tokens = set(tokenise(role))
    if "primary" in tokens:
        return due_dates["first"]
    if "secondary" in tokens:
        return due_dates["second"]
    if "first" in tokens:
        return due_dates["first"]
    if "second" in tokens:
        return due_dates["second"]
    return due_dates["additional"]


def tokenise(text: str) -> List[str]:
    return NAME_TOKEN_RE.findall(text.lower())


def canonical_name(value: str) -> str:
    tokens = tokenise(value)
    return " ".join(tokens)


def load_assignments(path: Path) -> List[Assignment]:
    if not path.is_file():
        raise FileNotFoundError(f"Assignments file not found: {path}")

    with path.open(newline="", encoding="utf-8") as handle:
        reader = csv.reader(handle)
        try:
            header = next(reader)
        except StopIteration:
            return []

        header_tokens = [column.strip() for column in header]
        if not header_tokens or not header_tokens[0].lower().startswith("proposal"):
            raise ValueError(f"Unexpected assignments header in {path}; first column must be 'Proposal'.")
        roles = header_tokens[1:]

        assignments: List[Assignment] = []
        for row in reader:
            if not row:
                continue
            proposal = row[0].strip()
            if not proposal:
                continue
            if not PROPOSAL_RE.fullmatch(proposal):
                continue
            for idx, role in enumerate(roles, start=1):
                if idx >= len(row):
                    break
                reviewer = row[idx].strip()
                if reviewer:
                    assignments.append(Assignment(proposal=proposal, reviewer=reviewer, role=role))
    return assignments


def parse_review_text(text: str) -> Dict[str, bool]:
    proposals: Dict[str, bool] = {}
    current_proposal: Optional[str] = None
    current_lines: List[str] = []

    def finalize_block(proposal: Optional[str], lines: List[str]) -> None:
        if not proposal:
            return
        sections: Dict[str, List[str]] = {label: [] for label in SECTION_LABELS}
        current_label: Optional[str] = None
        for line in lines:
            stripped = line.strip()
            if re.fullmatch(r"=+", stripped):
                continue
            matched_label = None
            for label in SECTION_LABELS:
                if stripped.startswith(label):
                    matched_label = label
                    remainder = stripped[len(label) :].strip()
                    if remainder:
                        sections[label].append(remainder)
                    current_label = label
                    break
            if matched_label:
                continue
            if current_label:
                sections[current_label].append(line)
        filled = any("".join(lines).strip() for lines in sections.values())
        proposals[proposal] = filled

    last_was_separator = False
    for line in text.splitlines():
        stripped = line.strip()
        if not stripped:
            if current_proposal is not None:
                current_lines.append(line)
            continue
        if re.fullmatch(r"=+", stripped):
            last_was_separator = True
            continue
        proposal_code = None
        header_match = PROPOSAL_HEADER_RE.match(line.lstrip())
        if header_match:
            proposal_code = header_match.group("code")
        elif last_was_separator:
            loose_match = PROPOSAL_RE.match(stripped)
            if loose_match:
                proposal_code = loose_match.group(0)
        if proposal_code:
            finalize_block(current_proposal, current_lines)
            current_proposal = proposal_code.upper()
            current_lines = [line]
            last_was_separator = False
            continue
        if current_proposal is not None:
            current_lines.append(line)
        last_was_separator = False

    finalize_block(current_proposal, current_lines)
    return proposals


def collect_review_files(reviews_dir: Path) -> List[ReviewFile]:
    if not reviews_dir.exists():
        return []
    signatures: List[ReviewFile] = []
    for path in sorted(reviews_dir.rglob("*")):
        if not path.is_file():
            continue
        tokens = tokenise(path.stem.replace("-", " "))
        if not tokens:
            continue
        proposals: Dict[str, bool] = {}
        if path.suffix.lower() == ".txt":
            try:
                content = path.read_text(encoding="utf-8", errors="replace")
            except OSError:
                content = ""
            proposals = parse_review_text(content)
        signatures.append(ReviewFile(path=path, tokens=tokens, proposals=proposals))
    return signatures


def review_is_submitted(
    proposal: str,
    reviewer: str,
    files: Iterable[ReviewFile],
) -> bool:
    proposal_key = proposal.upper()
    reviewer_tokens = tokenise(reviewer)
    if not proposal_key or not reviewer_tokens:
        return False

    reviewer_token_set = set(reviewer_tokens)
    for review_file in files:
        token_set = set(review_file.tokens)
        if not reviewer_token_set.issubset(token_set):
            continue
        status = review_file.proposals.get(proposal_key)
        if status is True:
            return True
    return False


def build_reminders(
    assignments: Sequence[Assignment],
    files: Iterable[ReviewFile],
    contacts: Mapping[str, str],
    due_dates: Mapping[str, datetime],
    current_date: datetime,
) -> Dict[str, Reminder]:
    reminders: Dict[str, Reminder] = {}
    file_cache = list(files)
    for assignment in assignments:
        role_due_date = due_date_for_role(assignment.role, due_dates)
        if current_date < role_due_date:
            continue

        if review_is_submitted(assignment.proposal, assignment.reviewer, file_cache):
            continue

        reviewer_key = canonical_name(assignment.reviewer)
        entry = reminders.get(reviewer_key)
        if entry is None:
            email = contacts.get(reviewer_key)
            entry = Reminder(reviewer=assignment.reviewer, email=email, proposals=[])
            reminders[reviewer_key] = entry
        entry.proposals.append((assignment.proposal, assignment.role))
    return reminders


def send_reminder_email(
    reminder: Reminder,
    today: datetime,
    subject_template: str,
    body_template: str,
    args: argparse.Namespace,
) -> None:
    if not reminder.proposals:
        return

    today_str = today.strftime("%Y-%m-%d")
    first_proposal, first_role = reminder.proposals[0]
    proposal_list = ", ".join(proposal for proposal, _ in reminder.proposals)
    details = "\n".join(f"- {proposal} ({role})" for proposal, role in reminder.proposals)
    context = {
        "reviewer": reminder.reviewer,
        "proposal": first_proposal,
        "role": first_role,
        "proposal_list": proposal_list,
        "details": details,
        "count": len(reminder.proposals),
        "today": today_str,
    }
    subject = subject_template.format(**context)
    body = body_template.format(**context)

    export_email_draft(reminder, subject, body, today, args)

    if not reminder.email:
        print(format_reminder_text(reminder, today), flush=True)
        print("  (No email address available; reminder not sent.)")
        return

    if args.dry_run:
        server_display = f"{args.smtp_server}:{args.smtp_port}" if args.smtp_server else "SMTP"
        cc_display = f" CC={', '.join(args.cc)}" if args.cc else ""
        print(
            f"[DRY-RUN] Would send via {server_display} to {reminder.email}{cc_display} :: {subject}\n{body}\n",
            flush=True,
        )
        return

    sender = args.from_address or args.smtp_username
    if not sender:
        raise ValueError("A --from-address (or SMTP username) is required to send emails.")

    message = EmailMessage()
    message["Subject"] = subject
    message["From"] = sender
    message["To"] = reminder.email
    if args.reply_to:
        message["Reply-To"] = args.reply_to
    if args.cc:
        message["Cc"] = ", ".join(args.cc)
    message.set_content(body)

    server_display = f"{args.smtp_server}:{args.smtp_port}" if args.smtp_server else "SMTP"
    cc_display = f" CC={', '.join(args.cc)}" if args.cc else ""
    print(f"[SENDING] via {server_display} to {reminder.email}{cc_display} :: {subject}", flush=True)
    deliver_email(args, message)
    print(f"[SENT] {reminder.email} ({reminder.reviewer})", flush=True)


def deliver_email(args: argparse.Namespace, message: EmailMessage) -> None:
    if args.smtp_use_ssl:
        server: smtplib.SMTP = smtplib.SMTP_SSL(args.smtp_server, args.smtp_port)
    else:
        server = smtplib.SMTP(args.smtp_server, args.smtp_port)
        server.ehlo()
        if not args.smtp_use_ssl:
            try:
                server.starttls()
                server.ehlo()
            except smtplib.SMTPException:
                pass
    try:
        if args.smtp_username and args.smtp_password:
            server.login(args.smtp_username, args.smtp_password)
        server.send_message(message)
    finally:
        server.quit()


def format_reminder_text(reminder: Reminder, today: datetime) -> str:
    lines = [
        f"Reminder for {reminder.reviewer} ({reminder.email or 'no email available'})",
        f"  Outstanding as of {today.strftime('%Y-%m-%d')}:",
    ]
    for proposal, role in reminder.proposals:
        lines.append(f"    - {proposal} ({role})")
    return "\n".join(lines)


def print_summary(reminders: Dict[str, Reminder], today: datetime) -> None:
    if not reminders:
        print(f"All reviews submitted as of {today.strftime('%Y-%m-%d')}.")
        return
    total = sum(len(item.proposals) for item in reminders.values())
    reviewers = ", ".join(sorted(item.reviewer for item in reminders.values()))
    print(f"{total} outstanding review(s) across {len(reminders)} reviewer(s): {reviewers}")


def export_email_draft(
    reminder: Reminder,
    subject: str,
    body: str,
    today: datetime,
    args: argparse.Namespace,
) -> None:
    export_dir: Optional[Path] = getattr(args, "export_emails", None)
    if not export_dir:
        return

    try:
        export_dir.mkdir(parents=True, exist_ok=True)
    except OSError as exc:
        print(f"Unable to create export directory {export_dir}: {exc}", file=sys.stderr)
        return

    today_stamp = today.strftime("%Y%m%d")
    reviewer_slug = "-".join(NAME_TOKEN_RE.findall(reminder.reviewer.lower())) or "reviewer"
    base_name = f"{today_stamp}_{reviewer_slug}"
    candidate = export_dir / f"{base_name}.txt"
    suffix = 1
    while candidate.exists():
        suffix += 1
        candidate = export_dir / f"{base_name}-{suffix:02d}.txt"

    headers = []
    sender = args.from_address or args.smtp_username or ""
    if sender:
        headers.append(f"From: {sender}")
    headers.append(f"To: {reminder.email or 'no email available'}")
    if args.cc:
        headers.append(f"Cc: {', '.join(args.cc)}")
    if args.reply_to:
        headers.append(f"Reply-To: {args.reply_to}")
    headers.append(f"Subject: {subject}")

    content = "\n".join([*headers, "", body])

    try:
        candidate.write_text(content, encoding="utf-8")
    except OSError as exc:
        print(f"Unable to write email draft for {reminder.reviewer}: {exc}", file=sys.stderr)
        return

    print(f"Saved reminder draft to {candidate}", flush=True)


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)

    try:
        current_date = parse_iso_datetime(args.current_date, "current date") if args.current_date else datetime.now()
    except ValueError as exc:
        print(exc, file=sys.stderr)
        return 2

    try:
        due_dates = load_due_dates(args.due_dates)
    except (FileNotFoundError, ValueError) as exc:
        print(exc, file=sys.stderr)
        return 1

    earliest_label, earliest_due = min(due_dates.items(), key=lambda item: item[1])
    if current_date < earliest_due:
        label_display = DUE_DATE_DISPLAY_NAMES.get(earliest_label, earliest_label.capitalize())
        print(
            f"Current date {current_date.strftime('%Y-%m-%d %H:%M')} is before the earliest "
            f"deadline ({label_display}: {earliest_due.strftime('%Y-%m-%d %H:%M')}); no reminders sent.",
        )
        return 0

    try:
        assignments = load_assignments(args.assignments)
    except (FileNotFoundError, ValueError) as exc:
        print(exc, file=sys.stderr)
        return 1

    try:
        _member_names, _fixed, member_emails, _chairs, _tags = load_pc_members(args.pc_members)
    except (FileNotFoundError, ValueError) as exc:
        print(exc, file=sys.stderr)
        return 1
    contacts: Dict[str, str] = {canonical_name(name): email for name, email in member_emails.items()}

    file_signatures = collect_review_files(args.reviews_dir)
    reminders = build_reminders(assignments, file_signatures, contacts, due_dates, current_date)

    print_summary(reminders, current_date)

    if args.summary_only or not reminders:
        return 0

    try:
        for reminder in reminders.values():
            send_reminder_email(reminder, current_date, args.subject_template, args.message_template, args)
    except ValueError as exc:
        print(exc, file=sys.stderr)
        return 1
    except smtplib.SMTPException as exc:
        print(f"SMTP error: {exc}", file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
